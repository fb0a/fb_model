// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package fb

import (
	"context"
	"database/sql"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"github.com/fb0a/fb_model/model"
)

func newFbBalanceTransaction(db *gorm.DB, opts ...gen.DOOption) fbBalanceTransaction {
	_fbBalanceTransaction := fbBalanceTransaction{}

	_fbBalanceTransaction.fbBalanceTransactionDo.UseDB(db, opts...)
	_fbBalanceTransaction.fbBalanceTransactionDo.UseModel(&model.FbBalanceTransaction{})

	tableName := _fbBalanceTransaction.fbBalanceTransactionDo.TableName()
	_fbBalanceTransaction.ALL = field.NewAsterisk(tableName)
	_fbBalanceTransaction.ID = field.NewUint64(tableName, "id")
	_fbBalanceTransaction.BillNo = field.NewString(tableName, "bill_no")
	_fbBalanceTransaction.UID = field.NewUint64(tableName, "uid")
	_fbBalanceTransaction.Username = field.NewString(tableName, "username")
	_fbBalanceTransaction.PlayerName = field.NewString(tableName, "player_name")
	_fbBalanceTransaction.CashType = field.NewInt32(tableName, "cash_type")
	_fbBalanceTransaction.BusinessType = field.NewInt32(tableName, "business_type")
	_fbBalanceTransaction.Amount = field.NewFloat64(tableName, "amount")
	_fbBalanceTransaction.BeforeAmount = field.NewFloat64(tableName, "before_amount")
	_fbBalanceTransaction.AfterAmount = field.NewFloat64(tableName, "after_amount")
	_fbBalanceTransaction.CreatedAt = field.NewUint64(tableName, "created_at")
	_fbBalanceTransaction.Tester = field.NewInt32(tableName, "tester")
	_fbBalanceTransaction.Remark = field.NewString(tableName, "remark")
	_fbBalanceTransaction.OperatorUID = field.NewUint64(tableName, "operator_uid")
	_fbBalanceTransaction.OperatorName = field.NewString(tableName, "operator_name")
	_fbBalanceTransaction.Device = field.NewInt32(tableName, "device")
	_fbBalanceTransaction.PlatformID = field.NewUint64(tableName, "platform_id")
	_fbBalanceTransaction.OperationNo = field.NewString(tableName, "operation_no")
	_fbBalanceTransaction.State = field.NewInt32(tableName, "state")
	_fbBalanceTransaction.DataType = field.NewInt32(tableName, "data_type")
	_fbBalanceTransaction.OriginAmount = field.NewString(tableName, "origin_amount")

	_fbBalanceTransaction.fillFieldMap()

	return _fbBalanceTransaction
}

// fbBalanceTransaction 账变表
type fbBalanceTransaction struct {
	fbBalanceTransactionDo

	ALL          field.Asterisk
	ID           field.Uint64
	BillNo       field.String  // 转账|充值|提现ID
	UID          field.Uint64  // 用户ID
	Username     field.String  // 用户名
	PlayerName   field.String  // 游戏帐号
	CashType     field.Int32   // 帐变类型
	BusinessType field.Int32   // 业务类型
	Amount       field.Float64 // 账变金额
	BeforeAmount field.Float64 // 账变前的金额（钱包）
	AfterAmount  field.Float64 // 账变后的金额（钱包）
	CreatedAt    field.Uint64  // 帐变时间
	Tester       field.Int32   // 1:正式2:测试3:代理
	Remark       field.String  // 备注
	OperatorUID  field.Uint64  // 操作人uid
	OperatorName field.String  // 操作人
	Device       field.Int32   // 操作终端
	PlatformID   field.Uint64  // 场馆id
	OperationNo  field.String  // 流水号
	State        field.Int32   // 状态(仅场馆业务类型使用) 1待结算 2已结算 3已取消 4重新结算
	DataType     field.Int32   // 1 mongo 2 新架构tidb 3 老架构tidb
	OriginAmount field.String  // 原始金额

	fieldMap map[string]field.Expr
}

func (f fbBalanceTransaction) Table(newTableName string) *fbBalanceTransaction {
	f.fbBalanceTransactionDo.UseTable(newTableName)
	return f.updateTableName(newTableName)
}

func (f fbBalanceTransaction) As(alias string) *fbBalanceTransaction {
	f.fbBalanceTransactionDo.DO = *(f.fbBalanceTransactionDo.As(alias).(*gen.DO))
	return f.updateTableName(alias)
}

func (f *fbBalanceTransaction) updateTableName(table string) *fbBalanceTransaction {
	f.ALL = field.NewAsterisk(table)
	f.ID = field.NewUint64(table, "id")
	f.BillNo = field.NewString(table, "bill_no")
	f.UID = field.NewUint64(table, "uid")
	f.Username = field.NewString(table, "username")
	f.PlayerName = field.NewString(table, "player_name")
	f.CashType = field.NewInt32(table, "cash_type")
	f.BusinessType = field.NewInt32(table, "business_type")
	f.Amount = field.NewFloat64(table, "amount")
	f.BeforeAmount = field.NewFloat64(table, "before_amount")
	f.AfterAmount = field.NewFloat64(table, "after_amount")
	f.CreatedAt = field.NewUint64(table, "created_at")
	f.Tester = field.NewInt32(table, "tester")
	f.Remark = field.NewString(table, "remark")
	f.OperatorUID = field.NewUint64(table, "operator_uid")
	f.OperatorName = field.NewString(table, "operator_name")
	f.Device = field.NewInt32(table, "device")
	f.PlatformID = field.NewUint64(table, "platform_id")
	f.OperationNo = field.NewString(table, "operation_no")
	f.State = field.NewInt32(table, "state")
	f.DataType = field.NewInt32(table, "data_type")
	f.OriginAmount = field.NewString(table, "origin_amount")

	f.fillFieldMap()

	return f
}

func (f *fbBalanceTransaction) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := f.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (f *fbBalanceTransaction) fillFieldMap() {
	f.fieldMap = make(map[string]field.Expr, 21)
	f.fieldMap["id"] = f.ID
	f.fieldMap["bill_no"] = f.BillNo
	f.fieldMap["uid"] = f.UID
	f.fieldMap["username"] = f.Username
	f.fieldMap["player_name"] = f.PlayerName
	f.fieldMap["cash_type"] = f.CashType
	f.fieldMap["business_type"] = f.BusinessType
	f.fieldMap["amount"] = f.Amount
	f.fieldMap["before_amount"] = f.BeforeAmount
	f.fieldMap["after_amount"] = f.AfterAmount
	f.fieldMap["created_at"] = f.CreatedAt
	f.fieldMap["tester"] = f.Tester
	f.fieldMap["remark"] = f.Remark
	f.fieldMap["operator_uid"] = f.OperatorUID
	f.fieldMap["operator_name"] = f.OperatorName
	f.fieldMap["device"] = f.Device
	f.fieldMap["platform_id"] = f.PlatformID
	f.fieldMap["operation_no"] = f.OperationNo
	f.fieldMap["state"] = f.State
	f.fieldMap["data_type"] = f.DataType
	f.fieldMap["origin_amount"] = f.OriginAmount
}

func (f fbBalanceTransaction) clone(db *gorm.DB) fbBalanceTransaction {
	f.fbBalanceTransactionDo.ReplaceConnPool(db.Statement.ConnPool)
	return f
}

func (f fbBalanceTransaction) replaceDB(db *gorm.DB) fbBalanceTransaction {
	f.fbBalanceTransactionDo.ReplaceDB(db)
	return f
}

type fbBalanceTransactionDo struct{ gen.DO }

type IFbBalanceTransactionDo interface {
	gen.SubQuery
	Debug() IFbBalanceTransactionDo
	WithContext(ctx context.Context) IFbBalanceTransactionDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IFbBalanceTransactionDo
	WriteDB() IFbBalanceTransactionDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IFbBalanceTransactionDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IFbBalanceTransactionDo
	Not(conds ...gen.Condition) IFbBalanceTransactionDo
	Or(conds ...gen.Condition) IFbBalanceTransactionDo
	Select(conds ...field.Expr) IFbBalanceTransactionDo
	Where(conds ...gen.Condition) IFbBalanceTransactionDo
	Order(conds ...field.Expr) IFbBalanceTransactionDo
	Distinct(cols ...field.Expr) IFbBalanceTransactionDo
	Omit(cols ...field.Expr) IFbBalanceTransactionDo
	Join(table schema.Tabler, on ...field.Expr) IFbBalanceTransactionDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IFbBalanceTransactionDo
	RightJoin(table schema.Tabler, on ...field.Expr) IFbBalanceTransactionDo
	Group(cols ...field.Expr) IFbBalanceTransactionDo
	Having(conds ...gen.Condition) IFbBalanceTransactionDo
	Limit(limit int) IFbBalanceTransactionDo
	Offset(offset int) IFbBalanceTransactionDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IFbBalanceTransactionDo
	Unscoped() IFbBalanceTransactionDo
	Create(values ...*model.FbBalanceTransaction) error
	CreateInBatches(values []*model.FbBalanceTransaction, batchSize int) error
	Save(values ...*model.FbBalanceTransaction) error
	First() (*model.FbBalanceTransaction, error)
	Take() (*model.FbBalanceTransaction, error)
	Last() (*model.FbBalanceTransaction, error)
	Find() ([]*model.FbBalanceTransaction, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.FbBalanceTransaction, err error)
	FindInBatches(result *[]*model.FbBalanceTransaction, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.FbBalanceTransaction) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IFbBalanceTransactionDo
	Assign(attrs ...field.AssignExpr) IFbBalanceTransactionDo
	Joins(fields ...field.RelationField) IFbBalanceTransactionDo
	Preload(fields ...field.RelationField) IFbBalanceTransactionDo
	FirstOrInit() (*model.FbBalanceTransaction, error)
	FirstOrCreate() (*model.FbBalanceTransaction, error)
	FindByPage(offset int, limit int) (result []*model.FbBalanceTransaction, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Rows() (*sql.Rows, error)
	Row() *sql.Row
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IFbBalanceTransactionDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (f fbBalanceTransactionDo) Debug() IFbBalanceTransactionDo {
	return f.withDO(f.DO.Debug())
}

func (f fbBalanceTransactionDo) WithContext(ctx context.Context) IFbBalanceTransactionDo {
	return f.withDO(f.DO.WithContext(ctx))
}

func (f fbBalanceTransactionDo) ReadDB() IFbBalanceTransactionDo {
	return f.Clauses(dbresolver.Read)
}

func (f fbBalanceTransactionDo) WriteDB() IFbBalanceTransactionDo {
	return f.Clauses(dbresolver.Write)
}

func (f fbBalanceTransactionDo) Session(config *gorm.Session) IFbBalanceTransactionDo {
	return f.withDO(f.DO.Session(config))
}

func (f fbBalanceTransactionDo) Clauses(conds ...clause.Expression) IFbBalanceTransactionDo {
	return f.withDO(f.DO.Clauses(conds...))
}

func (f fbBalanceTransactionDo) Returning(value interface{}, columns ...string) IFbBalanceTransactionDo {
	return f.withDO(f.DO.Returning(value, columns...))
}

func (f fbBalanceTransactionDo) Not(conds ...gen.Condition) IFbBalanceTransactionDo {
	return f.withDO(f.DO.Not(conds...))
}

func (f fbBalanceTransactionDo) Or(conds ...gen.Condition) IFbBalanceTransactionDo {
	return f.withDO(f.DO.Or(conds...))
}

func (f fbBalanceTransactionDo) Select(conds ...field.Expr) IFbBalanceTransactionDo {
	return f.withDO(f.DO.Select(conds...))
}

func (f fbBalanceTransactionDo) Where(conds ...gen.Condition) IFbBalanceTransactionDo {
	return f.withDO(f.DO.Where(conds...))
}

func (f fbBalanceTransactionDo) Order(conds ...field.Expr) IFbBalanceTransactionDo {
	return f.withDO(f.DO.Order(conds...))
}

func (f fbBalanceTransactionDo) Distinct(cols ...field.Expr) IFbBalanceTransactionDo {
	return f.withDO(f.DO.Distinct(cols...))
}

func (f fbBalanceTransactionDo) Omit(cols ...field.Expr) IFbBalanceTransactionDo {
	return f.withDO(f.DO.Omit(cols...))
}

func (f fbBalanceTransactionDo) Join(table schema.Tabler, on ...field.Expr) IFbBalanceTransactionDo {
	return f.withDO(f.DO.Join(table, on...))
}

func (f fbBalanceTransactionDo) LeftJoin(table schema.Tabler, on ...field.Expr) IFbBalanceTransactionDo {
	return f.withDO(f.DO.LeftJoin(table, on...))
}

func (f fbBalanceTransactionDo) RightJoin(table schema.Tabler, on ...field.Expr) IFbBalanceTransactionDo {
	return f.withDO(f.DO.RightJoin(table, on...))
}

func (f fbBalanceTransactionDo) Group(cols ...field.Expr) IFbBalanceTransactionDo {
	return f.withDO(f.DO.Group(cols...))
}

func (f fbBalanceTransactionDo) Having(conds ...gen.Condition) IFbBalanceTransactionDo {
	return f.withDO(f.DO.Having(conds...))
}

func (f fbBalanceTransactionDo) Limit(limit int) IFbBalanceTransactionDo {
	return f.withDO(f.DO.Limit(limit))
}

func (f fbBalanceTransactionDo) Offset(offset int) IFbBalanceTransactionDo {
	return f.withDO(f.DO.Offset(offset))
}

func (f fbBalanceTransactionDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IFbBalanceTransactionDo {
	return f.withDO(f.DO.Scopes(funcs...))
}

func (f fbBalanceTransactionDo) Unscoped() IFbBalanceTransactionDo {
	return f.withDO(f.DO.Unscoped())
}

func (f fbBalanceTransactionDo) Create(values ...*model.FbBalanceTransaction) error {
	if len(values) == 0 {
		return nil
	}
	return f.DO.Create(values)
}

func (f fbBalanceTransactionDo) CreateInBatches(values []*model.FbBalanceTransaction, batchSize int) error {
	return f.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (f fbBalanceTransactionDo) Save(values ...*model.FbBalanceTransaction) error {
	if len(values) == 0 {
		return nil
	}
	return f.DO.Save(values)
}

func (f fbBalanceTransactionDo) First() (*model.FbBalanceTransaction, error) {
	if result, err := f.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.FbBalanceTransaction), nil
	}
}

func (f fbBalanceTransactionDo) Take() (*model.FbBalanceTransaction, error) {
	if result, err := f.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.FbBalanceTransaction), nil
	}
}

func (f fbBalanceTransactionDo) Last() (*model.FbBalanceTransaction, error) {
	if result, err := f.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.FbBalanceTransaction), nil
	}
}

func (f fbBalanceTransactionDo) Find() ([]*model.FbBalanceTransaction, error) {
	result, err := f.DO.Find()
	return result.([]*model.FbBalanceTransaction), err
}

func (f fbBalanceTransactionDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.FbBalanceTransaction, err error) {
	buf := make([]*model.FbBalanceTransaction, 0, batchSize)
	err = f.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (f fbBalanceTransactionDo) FindInBatches(result *[]*model.FbBalanceTransaction, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return f.DO.FindInBatches(result, batchSize, fc)
}

func (f fbBalanceTransactionDo) Attrs(attrs ...field.AssignExpr) IFbBalanceTransactionDo {
	return f.withDO(f.DO.Attrs(attrs...))
}

func (f fbBalanceTransactionDo) Assign(attrs ...field.AssignExpr) IFbBalanceTransactionDo {
	return f.withDO(f.DO.Assign(attrs...))
}

func (f fbBalanceTransactionDo) Joins(fields ...field.RelationField) IFbBalanceTransactionDo {
	for _, _f := range fields {
		f = *f.withDO(f.DO.Joins(_f))
	}
	return &f
}

func (f fbBalanceTransactionDo) Preload(fields ...field.RelationField) IFbBalanceTransactionDo {
	for _, _f := range fields {
		f = *f.withDO(f.DO.Preload(_f))
	}
	return &f
}

func (f fbBalanceTransactionDo) FirstOrInit() (*model.FbBalanceTransaction, error) {
	if result, err := f.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.FbBalanceTransaction), nil
	}
}

func (f fbBalanceTransactionDo) FirstOrCreate() (*model.FbBalanceTransaction, error) {
	if result, err := f.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.FbBalanceTransaction), nil
	}
}

func (f fbBalanceTransactionDo) FindByPage(offset int, limit int) (result []*model.FbBalanceTransaction, count int64, err error) {
	result, err = f.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = f.Offset(-1).Limit(-1).Count()
	return
}

func (f fbBalanceTransactionDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = f.Count()
	if err != nil {
		return
	}

	err = f.Offset(offset).Limit(limit).Scan(result)
	return
}

func (f fbBalanceTransactionDo) Scan(result interface{}) (err error) {
	return f.DO.Scan(result)
}

func (f fbBalanceTransactionDo) Delete(models ...*model.FbBalanceTransaction) (result gen.ResultInfo, err error) {
	return f.DO.Delete(models)
}

func (f *fbBalanceTransactionDo) withDO(do gen.Dao) *fbBalanceTransactionDo {
	f.DO = *do.(*gen.DO)
	return f
}
