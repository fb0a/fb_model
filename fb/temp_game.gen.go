// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package fb

import (
	"context"
	"database/sql"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"github.com/fb0a/fb_model/model"
)

func newTempGame(db *gorm.DB, opts ...gen.DOOption) tempGame {
	_tempGame := tempGame{}

	_tempGame.tempGameDo.UseDB(db, opts...)
	_tempGame.tempGameDo.UseModel(&model.TempGame{})

	tableName := _tempGame.tempGameDo.TableName()
	_tempGame.ALL = field.NewAsterisk(tableName)
	_tempGame.GameType = field.NewInt64(tableName, "game_type")
	_tempGame.GameTypeName = field.NewString(tableName, "game_type_name")

	_tempGame.fillFieldMap()

	return _tempGame
}

type tempGame struct {
	tempGameDo

	ALL          field.Asterisk
	GameType     field.Int64
	GameTypeName field.String

	fieldMap map[string]field.Expr
}

func (t tempGame) Table(newTableName string) *tempGame {
	t.tempGameDo.UseTable(newTableName)
	return t.updateTableName(newTableName)
}

func (t tempGame) As(alias string) *tempGame {
	t.tempGameDo.DO = *(t.tempGameDo.As(alias).(*gen.DO))
	return t.updateTableName(alias)
}

func (t *tempGame) updateTableName(table string) *tempGame {
	t.ALL = field.NewAsterisk(table)
	t.GameType = field.NewInt64(table, "game_type")
	t.GameTypeName = field.NewString(table, "game_type_name")

	t.fillFieldMap()

	return t
}

func (t *tempGame) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := t.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (t *tempGame) fillFieldMap() {
	t.fieldMap = make(map[string]field.Expr, 2)
	t.fieldMap["game_type"] = t.GameType
	t.fieldMap["game_type_name"] = t.GameTypeName
}

func (t tempGame) clone(db *gorm.DB) tempGame {
	t.tempGameDo.ReplaceConnPool(db.Statement.ConnPool)
	return t
}

func (t tempGame) replaceDB(db *gorm.DB) tempGame {
	t.tempGameDo.ReplaceDB(db)
	return t
}

type tempGameDo struct{ gen.DO }

type ITempGameDo interface {
	gen.SubQuery
	Debug() ITempGameDo
	WithContext(ctx context.Context) ITempGameDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() ITempGameDo
	WriteDB() ITempGameDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) ITempGameDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) ITempGameDo
	Not(conds ...gen.Condition) ITempGameDo
	Or(conds ...gen.Condition) ITempGameDo
	Select(conds ...field.Expr) ITempGameDo
	Where(conds ...gen.Condition) ITempGameDo
	Order(conds ...field.Expr) ITempGameDo
	Distinct(cols ...field.Expr) ITempGameDo
	Omit(cols ...field.Expr) ITempGameDo
	Join(table schema.Tabler, on ...field.Expr) ITempGameDo
	LeftJoin(table schema.Tabler, on ...field.Expr) ITempGameDo
	RightJoin(table schema.Tabler, on ...field.Expr) ITempGameDo
	Group(cols ...field.Expr) ITempGameDo
	Having(conds ...gen.Condition) ITempGameDo
	Limit(limit int) ITempGameDo
	Offset(offset int) ITempGameDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) ITempGameDo
	Unscoped() ITempGameDo
	Create(values ...*model.TempGame) error
	CreateInBatches(values []*model.TempGame, batchSize int) error
	Save(values ...*model.TempGame) error
	First() (*model.TempGame, error)
	Take() (*model.TempGame, error)
	Last() (*model.TempGame, error)
	Find() ([]*model.TempGame, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.TempGame, err error)
	FindInBatches(result *[]*model.TempGame, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.TempGame) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) ITempGameDo
	Assign(attrs ...field.AssignExpr) ITempGameDo
	Joins(fields ...field.RelationField) ITempGameDo
	Preload(fields ...field.RelationField) ITempGameDo
	FirstOrInit() (*model.TempGame, error)
	FirstOrCreate() (*model.TempGame, error)
	FindByPage(offset int, limit int) (result []*model.TempGame, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Rows() (*sql.Rows, error)
	Row() *sql.Row
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) ITempGameDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (t tempGameDo) Debug() ITempGameDo {
	return t.withDO(t.DO.Debug())
}

func (t tempGameDo) WithContext(ctx context.Context) ITempGameDo {
	return t.withDO(t.DO.WithContext(ctx))
}

func (t tempGameDo) ReadDB() ITempGameDo {
	return t.Clauses(dbresolver.Read)
}

func (t tempGameDo) WriteDB() ITempGameDo {
	return t.Clauses(dbresolver.Write)
}

func (t tempGameDo) Session(config *gorm.Session) ITempGameDo {
	return t.withDO(t.DO.Session(config))
}

func (t tempGameDo) Clauses(conds ...clause.Expression) ITempGameDo {
	return t.withDO(t.DO.Clauses(conds...))
}

func (t tempGameDo) Returning(value interface{}, columns ...string) ITempGameDo {
	return t.withDO(t.DO.Returning(value, columns...))
}

func (t tempGameDo) Not(conds ...gen.Condition) ITempGameDo {
	return t.withDO(t.DO.Not(conds...))
}

func (t tempGameDo) Or(conds ...gen.Condition) ITempGameDo {
	return t.withDO(t.DO.Or(conds...))
}

func (t tempGameDo) Select(conds ...field.Expr) ITempGameDo {
	return t.withDO(t.DO.Select(conds...))
}

func (t tempGameDo) Where(conds ...gen.Condition) ITempGameDo {
	return t.withDO(t.DO.Where(conds...))
}

func (t tempGameDo) Order(conds ...field.Expr) ITempGameDo {
	return t.withDO(t.DO.Order(conds...))
}

func (t tempGameDo) Distinct(cols ...field.Expr) ITempGameDo {
	return t.withDO(t.DO.Distinct(cols...))
}

func (t tempGameDo) Omit(cols ...field.Expr) ITempGameDo {
	return t.withDO(t.DO.Omit(cols...))
}

func (t tempGameDo) Join(table schema.Tabler, on ...field.Expr) ITempGameDo {
	return t.withDO(t.DO.Join(table, on...))
}

func (t tempGameDo) LeftJoin(table schema.Tabler, on ...field.Expr) ITempGameDo {
	return t.withDO(t.DO.LeftJoin(table, on...))
}

func (t tempGameDo) RightJoin(table schema.Tabler, on ...field.Expr) ITempGameDo {
	return t.withDO(t.DO.RightJoin(table, on...))
}

func (t tempGameDo) Group(cols ...field.Expr) ITempGameDo {
	return t.withDO(t.DO.Group(cols...))
}

func (t tempGameDo) Having(conds ...gen.Condition) ITempGameDo {
	return t.withDO(t.DO.Having(conds...))
}

func (t tempGameDo) Limit(limit int) ITempGameDo {
	return t.withDO(t.DO.Limit(limit))
}

func (t tempGameDo) Offset(offset int) ITempGameDo {
	return t.withDO(t.DO.Offset(offset))
}

func (t tempGameDo) Scopes(funcs ...func(gen.Dao) gen.Dao) ITempGameDo {
	return t.withDO(t.DO.Scopes(funcs...))
}

func (t tempGameDo) Unscoped() ITempGameDo {
	return t.withDO(t.DO.Unscoped())
}

func (t tempGameDo) Create(values ...*model.TempGame) error {
	if len(values) == 0 {
		return nil
	}
	return t.DO.Create(values)
}

func (t tempGameDo) CreateInBatches(values []*model.TempGame, batchSize int) error {
	return t.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (t tempGameDo) Save(values ...*model.TempGame) error {
	if len(values) == 0 {
		return nil
	}
	return t.DO.Save(values)
}

func (t tempGameDo) First() (*model.TempGame, error) {
	if result, err := t.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.TempGame), nil
	}
}

func (t tempGameDo) Take() (*model.TempGame, error) {
	if result, err := t.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.TempGame), nil
	}
}

func (t tempGameDo) Last() (*model.TempGame, error) {
	if result, err := t.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.TempGame), nil
	}
}

func (t tempGameDo) Find() ([]*model.TempGame, error) {
	result, err := t.DO.Find()
	return result.([]*model.TempGame), err
}

func (t tempGameDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.TempGame, err error) {
	buf := make([]*model.TempGame, 0, batchSize)
	err = t.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (t tempGameDo) FindInBatches(result *[]*model.TempGame, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return t.DO.FindInBatches(result, batchSize, fc)
}

func (t tempGameDo) Attrs(attrs ...field.AssignExpr) ITempGameDo {
	return t.withDO(t.DO.Attrs(attrs...))
}

func (t tempGameDo) Assign(attrs ...field.AssignExpr) ITempGameDo {
	return t.withDO(t.DO.Assign(attrs...))
}

func (t tempGameDo) Joins(fields ...field.RelationField) ITempGameDo {
	for _, _f := range fields {
		t = *t.withDO(t.DO.Joins(_f))
	}
	return &t
}

func (t tempGameDo) Preload(fields ...field.RelationField) ITempGameDo {
	for _, _f := range fields {
		t = *t.withDO(t.DO.Preload(_f))
	}
	return &t
}

func (t tempGameDo) FirstOrInit() (*model.TempGame, error) {
	if result, err := t.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.TempGame), nil
	}
}

func (t tempGameDo) FirstOrCreate() (*model.TempGame, error) {
	if result, err := t.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.TempGame), nil
	}
}

func (t tempGameDo) FindByPage(offset int, limit int) (result []*model.TempGame, count int64, err error) {
	result, err = t.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = t.Offset(-1).Limit(-1).Count()
	return
}

func (t tempGameDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = t.Count()
	if err != nil {
		return
	}

	err = t.Offset(offset).Limit(limit).Scan(result)
	return
}

func (t tempGameDo) Scan(result interface{}) (err error) {
	return t.DO.Scan(result)
}

func (t tempGameDo) Delete(models ...*model.TempGame) (result gen.ResultInfo, err error) {
	return t.DO.Delete(models)
}

func (t *tempGameDo) withDO(do gen.Dao) *tempGameDo {
	t.DO = *do.(*gen.DO)
	return t
}
